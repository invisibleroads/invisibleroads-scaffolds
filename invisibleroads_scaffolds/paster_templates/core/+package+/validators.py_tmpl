from formencode import Invalid
from formencode.validators import FormValidator, Int
from markupsafe import escape

from {{package}}.models import User, db


class FormState(object):

    def __init__(self, userID):
        self.userID = self.user_id = userID
        self.cache = {}

    def get(self, TargetClass, targetID):
        'Return cached targetInstance'
        key = TargetClass, targetID
        try:
            target = self.cache[key]
        except KeyError:
            target = db.query(TargetClass).get(targetID) if targetID else None
            self.cache[key] = target
        return target


class Unique(FormValidator):
    """
    Ensure that the value of a field is unique within a group.
    Use FormState when using this validator.
    """

    groupFieldName = None
    __unpackargs__ = ['errorMessage', 'TargetClass', 'uniqueFieldName', 'groupFieldName']

    def validate_python(self, field_dict, state):
        target = state.get(self.TargetClass, field_dict['id'])
        uniqueFieldValue = field_dict[self.uniqueFieldName]
        # Check database only if target doesn't exist or uniqueFieldValue differs
        if not target or getattr(target, self.uniqueFieldName) != uniqueFieldValue:
            uniqueAttribute = getattr(self.TargetClass, self.uniqueFieldName)
            uniqueQuery = db.query(uniqueAttribute)
            if self.groupFieldName:
                try:
                    groupFieldValue = field_dict[self.groupFieldName]
                except KeyError:
                    groupFieldValue = getattr(state, self.groupFieldName)
                groupAttribute = getattr(self.TargetClass, self.groupFieldName)
                uniqueQuery = uniqueQuery.filter(groupAttribute==groupFieldValue)
            if uniqueQuery.filter(uniqueAttribute==uniqueFieldValue).first():
                raise Invalid(self.errorMessage, field_dict, state, error_dict={self.uniqueFieldName: self.errorMessage})


class MembersCannotSetTargetUser(FormValidator):

    __unpackargs__ = ['userIDFieldName']

    def validate_python(self, field_dict, state):
        userID = state.userID
        targetUserID = field_dict[self.userIDFieldName]
        isLeader = User.unpack_properties(userID, 'isLeader')[0]
        if not isLeader and targetUserID != userID:
            message = 'Cannot set a target user other than yourself'
            raise Invalid(message, field_dict, state, error_dict={self.userIDFieldName: message})


class UsersCanOmit(FormValidator):
    """
    If the field is missing, assume field's value from state.
    Use FormState when using this validator.
    """

    __unpackargs__ = ['fieldName', 'stateName']

    def validate_python(self, field_dict, state):
        fieldValue = field_dict[self.fieldName]
        # If the field is missing,
        if fieldValue is None:
            # Assume field's value from state
            stateValue = getattr(state, self.stateName)
            field_dict[self.fieldName] = stateValue


class UsersCannotChangeOwn(FormValidator):

    __unpackargs__ = ['restrictedFieldName', 'userIDFieldName']

    def validate_python(self, field_dict, state):
        if state.userID == field_dict[self.userIDFieldName]:
            message = 'Cannot change your own ' + self.restrictedFieldName
            raise Invalid(message, field_dict, state, error_dict={self.restrictedFieldName: message})


class ItemsExist(FormValidator):
    'Make sure that the items in the given heap exist.'

    queryConditional = None
    groupFieldName = None
    __unpackargs__ = ['TargetClass', 'attributeName', 'heapFieldName', 'groupFieldName']

    def validate_python(self, field_dict, state):
        get_name = lambda x: getattr(x, self.attributeName)
        heapFieldValue = field_dict[self.heapFieldName]
        if heapFieldValue is None or heapFieldValue == []:
            return
        itemNames = set(filter(lambda x: x, (line.strip() for line in heapFieldValue.splitlines())))
        if itemNames:
            itemQuery = db.query(self.TargetClass).filter(get_name(self.TargetClass).in_(itemNames))
            if self.queryConditional is not None:
                itemQuery = itemQuery.filter(self.queryConditional)
            if self.groupFieldName:
                try:
                    groupFieldValue = field_dict[self.groupFieldName]
                except KeyError:
                    groupFieldValue = getattr(state, self.groupFieldName)
                itemQuery = itemQuery.filter(getattr(self.TargetClass, self.groupFieldName)==groupFieldValue)
            items = itemQuery.all()
            unrecognizedNames = list(itemNames.difference(get_name(x) for x in items))
            if unrecognizedNames:
                message = '%s not recognized:<br>%s' % (
                    self.TargetClass.__name__, 
                    '\n'.join(unrecognizedNames[:3]))
                if len(unrecognizedNames) > 3:
                    message += '<br>...'
                raise Invalid(message, field_dict, state, error_dict={self.heapFieldName: message})
        else:
            items = []
        field_dict[self.heapFieldName] = items


class IDExists(Int):
    """
    Ensure that the database object exists.
    Use FormState when using this validator.
    """

    __unpackargs__ = ['TargetClass']

    def _to_python(self, value, state):
        targetID = super(IDExists, self)._to_python(value, state)
        target = state.get(self.TargetClass, targetID)
        if not target:
            raise Invalid('Could not find %s.id=%s' % (self.TargetClass.__name__, targetID), value, state)
        return targetID


class IDExistsAndBelongsToUser(IDExists):
    """
    Ensure that the target object belongs to the user.
    Use FormState when using this validator.
    """

    leadersEditAll = False
    __unpackargs__ = ['TargetClass', 'leadersEditAll']

    def _to_python(self, value, state):
        targetID = super(IDExistsAndBelongsToUser, self)._to_python(value, state)
        target = state.get(self.TargetClass, targetID)
        userID = state.userID
        if userID != target.user_id:
            isLeader = User.unpack_properties(userID, 'isLeader')[0]
            if not isLeader or not self.leadersEditAll:
                message = 'You can update your information only'
                raise Invalid(message, value, state)
        return targetID
