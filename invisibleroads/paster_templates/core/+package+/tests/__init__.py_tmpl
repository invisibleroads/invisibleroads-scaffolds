# -*- coding: utf-8 -*-
import os
import re
import simplejson
import transaction
from unittest import TestCase
from webtest import TestApp

from {{package}} import SettingsParser, main
from {{package}}.models import User, Base, db, ROLE_LEADER, ROLE_MEMBER, ROLE_SPECTATOR


WORD = 'Спасибо'.decode('utf-8')
WORD1, WORD2, WORD3, WORD4 = [WORD + str(x) for x in xrange(1, 5)]
TOKEN_SOURCE = 'user_update'
PATTERN_TOKEN = re.compile(r"token = '(.*)'")
BASE_PATH = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
CONFIGURATION_PATH = os.path.join(BASE_PATH, 'test.ini')
SETTINGS = SettingsParser(dict(here=BASE_PATH)).load(CONFIGURATION_PATH, storeConfigParser=True)


class TestRoute(object):

    # routeName = ''
    urlParams = dict()
    requestMethod = 'GET'
    requestParams = dict()
    # usersAllowed = []
    isPublic = False

    router = main(dict(__file__=CONFIGURATION_PATH, here=BASE_PATH), **SETTINGS)
    app = TestApp(router)
    settings = router.registry.settings # Include settings added by main()

    def setUp(self):
        self.supportsCaseInsensitiveUnicode = Base.metadata.bind.name != 'sqlite'
        self.requiresToken = 'POST' == self.requestMethod and not self.isPublic
        # Reset users
        self.leader = dict(role=ROLE_LEADER)
        self.member = dict(role=ROLE_MEMBER)
        self.spectator = dict(role=ROLE_SPECTATOR)
        self.userDs = [
            self.leader,
            self.member,
            self.spectator]
        for userID, userD in enumerate(self.userDs, 1):
            word = WORD + str(userID)
            build_dict(User, userD,
                id=userID,
                username=word,
                password=word,
                nickname=word,
                email=word + '@example.com',
                rejection_count=0)
        delete_extraneous(User, self.userDs)
        transaction.commit()

    def request(self, urlParams=None, **kw):
        url = self.get_url(self.routeName, **(urlParams or {}))
        params = dict(self.requestParams, **kw)
        return self.request_url(url, self.requestMethod, params, self.requiresToken)

    def request_url(self, url, requestMethod='GET', params=None, withToken=False):
        'Send an HTTPRequest; parameters with a value of None are excluded'
        parameters = {}
        for key, value in (params or {}).iteritems():
            if value is None:
                continue
            try:
                value = value.encode('utf-8')
            except (AttributeError, UnicodeDecodeError):
                pass
            parameters[key] = value
        if withToken:
            parameters['token'] = self.get_token()
        send = getattr(self.app, requestMethod.lower())
        return send(url, parameters)

    def login(self, userD, **kw):
        url = self.get_url('user_login')
        return self.request_url(url, 'POST', dict(userD, **kw))

    def logout(self):
        url = self.get_url('user_logout')
        return self.request_url(url, 'POST')

    def access_allowed(self, url, requestMethod, withToken=False):
        self.access_url(url, requestMethod, withToken, isAllowed=True)

    def access_denied(self, url, requestMethod, withToken=False):
        self.access_url(url, requestMethod, withToken, isAllowed=False)

    def access_url(self, url, requestMethod, withToken=False, isAllowed=True):
        body = self.request_url(url, requestMethod, withToken=withToken).body
        self.assertEqual('Elevated privileges required' in body, not isAllowed)

    def ajax_succeeded(self, **kw):
        return self.ajax(1, **kw)

    def ajax_failed(self, **kw):
        return self.ajax(0, **kw)

    def ajax(self, isOk, **kw):
        response = self.request(**kw)
        return assert_isOk(isOk, response)

    def ajax_url(self, isOk, url, requestMethod='POST', params=None, withToken=True):
        response = self.request_url(url, requestMethod, params, withToken)
        return assert_isOk(isOk, response)

    def assert_field_rejects_duplicates(self, fieldName, duplicateValue, **params):
        self.ajax_failed(**dict(params, **{fieldName: duplicateValue}))
        if self.supportsCaseInsensitiveUnicode: # pragma: no cover
            self.ajax_failed(**dict(params, **{fieldName: duplicateValue.upper()}))
            self.ajax_failed(**dict(params, **{fieldName: duplicateValue.lower()}))

    def get_url(self, routeName, **urlParams):
        return self.router.routes_mapper.generate(routeName, dict(self.urlParams, **urlParams))

    def get_token(self):
        tokenURL = self.get_url(TOKEN_SOURCE)
        return extract_token(self.request_url(tokenURL).body)

    def test_permissions(self):
        url = self.get_url(self.routeName, **self.urlParams)
        if self.isPublic:
            self.logout()
            self.access_allowed(url, self.requestMethod, self.requiresToken)
            return
        for userD in self.usersAllowed:
            self.login(userD)
            self.access_allowed(url, self.requestMethod, self.requiresToken)
            if self.requiresToken:
                self.access_denied(url, self.requestMethod)
        for userD in filter(lambda x: x not in self.usersAllowed, self.userDs):
            self.login(userD)
            self.access_denied(url, self.requestMethod, self.requiresToken)


def extract_token(html):
    match = PATTERN_TOKEN.search(html)
    return match.group(1) if match else ''


def assert_isOk(isOk, response):
    data = simplejson.loads(response.text)
    assert isOk == data.get('isOk'), data
    return data


def build_dict(TargetClass, targetDict=None, **kw):
    'Store object safely in database and return contents as dictionary'
    if not targetDict:
        targetDict = {}
    combinedDict = dict(targetDict, **kw)
    targetID = combinedDict.get('id')
    target = db.query(TargetClass).get(targetID) if targetID else None
    if not target:
        target = TargetClass()
        db.add(target)
        db.flush()
        targetID = target.id
    targetDict['id'] = targetID
    for key, value in combinedDict.iteritems():
        setattr(target, key, value)
        targetDict[key] = value
    return targetDict


def delete_extraneous(Class, classInstances):
    db.execute(Class.__table__.delete().where(~Class.id.in_(x['id'] for x in classInstances)))
