# -*- coding: utf-8 -*-
'Test templates'
import os
import re
import webtest
import shutil
import unittest
import simplejson
import transaction
import warnings; warnings.simplefilter('error')
from pyramid.request import Request

from {{package}} import main, load_settings, ApplicationError
from {{package}}.models import db, User, ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER, CaseInsensitiveUnicode
from {{package}}.libraries.tools import make_random_unique_string, get_remote_ip


basePath = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
configurationPath = os.path.join(basePath, 'test.ini')
settings = load_settings(configurationPath, basePath)


class ReplaceableDict(dict):
    
    def replace(self, **kwargs):
        return ReplaceableDict(self.items() + kwargs.items())

    def hide(self, *keys):
        x = self.copy()
        for key in keys:
            if key in x:
                del x[key]
        return x


class TestTemplate(unittest.TestCase):

    router = main({'__file__': configurationPath}, **settings)
    app = webtest.TestApp(router)
    settings = router.registry.settings

    def setUp(self):
        # Initialize functional test framework
        self.logout()
        word = 'Спасибо'.decode('utf-8')
        # Reset testUsers
        self.userL = ReplaceableDict(role=ROLE_LEADER)
        self.userM = ReplaceableDict(role=ROLE_MEMBER)
        self.userS = ReplaceableDict(role=ROLE_SPECTATOR)
        testUsers = [self.userL, self.userM, self.userS]
        for userID, userD in enumerate(testUsers, 1):
            wordNumber = word + str(userID)
            userD['id'] = userID
            userD['username'] = wordNumber
            userD['password'] = wordNumber
            userD['nickname'] = wordNumber
            userD['email'] = wordNumber + '@example.com'
            db.merge(User(**userD.replace(rejection_count=0)))
        transaction.commit()

    def get_url(self, name, **kwargs):
        'Return URL for route'
        return self.router.routes_mapper.generate(name, kwargs)

    def get(self, url, params=None):
        'Send a GET request'
        return self.app.get(url, unicode_dictionary(params))

    def post(self, url, params=None):
        'Send a POST request'
        return self.app.post(url, unicode_dictionary(params))

    def login(self, userD, **kwargs):
        'Login using credentials'
        return self.post(self.get_url('user_login'), ReplaceableDict(userD, **kwargs))

    def logout(self):
        'Logout'
        return self.post(self.get_url('user_logout'))

    def assert_json(self, response, isOk):
        'Assert response JSON'
        data = simplejson.loads(response.unicode_body)
        self.assertEqual(data['isOk'], isOk)
        return data

    def assert_forbidden(self, url, isForbidden=True, method='GET'):
        'Return True if the page is forbidden'
        body = getattr(self, method.lower())(url).body
        return self.assertEqual('Login</title>' in body, isForbidden)


class TestMiscellaneous(unittest.TestCase):

    def test_load_settings(self):
        'Make sure we can load settings properly'
        self.assertRaises(ApplicationError, load_settings, configurationPath + 'x', basePath)

    def test_make_random_unique_string(self):
        'Test the limits of make_random_unique_string()'
        self.assertRaises(RuntimeError, make_random_unique_string, 1, lambda x: False)

    def test_get_remote_ip(self):
        'Test get_remote_ip()'
        ip = '127.0.0.1'
        self.assertEqual(get_remote_ip(Request({'HTTP_X_REAL_IP': ip})), ip)
        self.assertEqual(get_remote_ip(Request({'HTTP_X_FORWARDED_FOR': ip})), ip)
        self.assertEqual(get_remote_ip(Request({'REMOTE_ADDR': ip})), ip)

    def test_CaseInsensitiveUnicode(self):
        'Test CaseInsensitiveUnicode'
        x = CaseInsensitiveUnicode('xxx')
        X = CaseInsensitiveUnicode('XXX')
        self.assertEqual(x < X, False)
        self.assertEqual(x <= X, True)
        self.assertEqual(x == X, True)
        self.assertEqual(x != X, False)
        self.assertEqual(x > X, False)
        self.assertEqual(x >= X, True)


def unicode_dictionary(dictionary):
    'Convert the values of the dictionary to unicode'
    if not dictionary:
        return {}
    return dict((key, value.encode('utf-8') if isinstance(value, unicode) else value) for key, value in dictionary.iteritems())


def get_token(html):
    'Extract token from html'
    match = re.search("token = '(.*)'", html)
    return match.group(1) if match else ''
