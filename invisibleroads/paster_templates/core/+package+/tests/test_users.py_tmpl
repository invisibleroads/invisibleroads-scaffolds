'Tests for user account management'
import imapIO
import unittest
from webob.request import environ_from_url
from pyramid.testing import DummyRequest
from pyramid.authentication import AuthTktCookieHelper
from urlparse import urlparse

from {{package}}.views import users
from {{package}}.libraries import sms
from {{package}}.models import db, User, User_, SMSAddress, ApplicationError, ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER
from {{package}}.tests import TestTemplate, ReplaceableDict, settings, get_token
from {{package}} import parameters


class TestUsers(TestTemplate):
    'Test views for users'

    def test_authentication(self):
        'Make sure authentication is robust'
        url = self.get_url('user_index')
        def get_body(secret, principal, tokens):
            request = DummyRequest(environ=environ_from_url(url))
            headers = AuthTktCookieHelper(secret).remember(request, principal, tokens=tokens)
            key, value = headers[0][1].split(';')[0].split('=')
            self.app.cookies = {key: value.strip('"')}
            return self.app.get(url).body
        user = db.query(User).get(self.userL['id'])
        tokens = users.format_tokens(user)
        secret = self.settings['authtkt.secret']
        params = ReplaceableDict(secret=secret, principal=self.userL['id'], tokens=tokens)
        # See what happens when we forge cookies poorly
        self.assert_('Logout' not in get_body(**params.replace(secret='')))
        self.assert_('Logout' not in get_body(**params.replace(principal=0)))
        self.assert_('Logout' not in get_body(**params.replace(principal='x')))
        self.assert_('Logout' not in get_body(**params.replace(tokens=[])))
        self.assert_('Logout' not in get_body(**params.replace(tokens=['x'])))
        # Fool authentication successfully
        self.assert_('Logout' in get_body(**params))

    def test_index(self):
        'Assert that the user index page is visible'
        url = self.get_url('user_index')
        # Make sure that the user index page is visible
        self.assert_('Users</title>' in self.get(url).unicode_body)

    def test_registration(self):
        'Make sure that registration works'
        url = self.get_url('user_register')
        username, password, nickname, email = [self.userL[x].replace('1', 'A') for x in 'username', 'password', 'nickname', 'email']
        params = ReplaceableDict(username=username, password=password, nickname=nickname, email=email)
        # Make sure the registration page appears properly
        self.assert_('Registration' in self.get(url).unicode_body)
        # Register
        registrationCount1 = db.query(User_).count()
        self.assert_json(self.post(url, params), 1)
        # Register with a username that already exists
        self.assert_json(self.post(url, params.replace(username=self.userL['username'])), 0)
        # Register with a nickname that already exists
        self.assert_json(self.post(url, params.replace(nickname=self.userL['nickname'])), 0)
        # Register with a email that already exists
        self.assert_json(self.post(url, params.replace(email=self.userL['email'])), 0)
        # Register with a weak password
        self.assert_json(self.post(url, params.replace(password='xxx')), 0)
        # Try different case
        params = ReplaceableDict(username=username + 'x', password=password + 'x', nickname=nickname + 'x', email=email + 'x')
        self.assert_json(self.post(url, params.replace(username=username.upper())), 1)
        self.assert_json(self.post(url, params.replace(nickname=nickname.upper())), 1)
        self.assert_json(self.post(url, params.replace(email=email.upper())), 1)
        # Confirm with an invalid ticket
        self.get(self.get_url('user_confirm', ticket='xxx'))
        # Confirm registration
        registrationCount2 = db.query(User_).count()
        self.assertEqual(registrationCount2 - registrationCount1, +4)
        self.confirm_ticket(email)
        # Make sure the user exists
        self.assertEqual(db.query(User).filter_by(email=email).count(), 1)
        # Make sure that conflicting registrations have been deleted
        registrationCount3 = db.query(User_).count()
        self.assertEqual(registrationCount3 - registrationCount2, -4)

    def test_login(self):
        'Make sure that login works'
        url = self.get_url('user_login')
        url_ = self.get_url('user_update')
        # Going to a forbidden page displays the login page
        self.assert_forbidden(url_)
        # Going directly to the login page stores the target url
        self.assert_(url_ in self.get(url, dict(url=url_)).unicode_body)
        # Bad credentials fail
        self.assert_json(self.login(self.userS.replace(username='')), 0)
        self.assert_json(self.login(self.userS.replace(password='')), 0)
        self.assert_json(self.login(self.userS.replace(username='xxx')), 0)
        self.assert_json(self.login(self.userS.replace(password='xxx')), 0)
        # Good credentials succeed
        self.assert_json(self.login(self.userS), 1)
        # Supply invalid timezone_offset
        self.assert_json(self.login(self.userS, timezone_offset='xxx'), 1)
        # Hit rejection limit
        for rejectionIndex in xrange(parameters.REJECTION_LIMIT):
            self.assert_json(self.login(self.userS.replace(password='xxx')), 0)
        self.assert_json(self.login(self.userS), 0)

    def test_logout(self):
        'Make sure that logout works'
        url = self.get_url('user_logout')
        url_ = self.get_url('user_index')
        # Logging out redirects whether the user is authenticated or not
        self.assertEqual(url_, urlparse(self.get(url, dict(url=url_)).location).path)
        self.login(self.userS)
        self.assertEqual(url_, urlparse(self.get(url, dict(url=url_)).location).path)

    def test_update(self):
        'Make sure that updating credentials works'
        url = self.get_url('user_update')
        # Check that we only see the login page if the user is not logged in
        self.assert_forbidden(url)
        self.assert_forbidden(url, method='POST')
        # Check that the update form is filled with the user's credentials
        self.login(self.userS)
        body = self.get(url).unicode_body
        self.assert_(self.userS['username'] in body)
        self.assert_(self.userS['nickname'] in body)
        self.assert_(self.userS['email'].lower() in body)
        token = get_token(body)
        # Updating credentials requires a token
        username, password, nickname, email = ['0' + self.userS[x] for x in 'username', 'password', 'nickname', 'email']
        params = ReplaceableDict(token=token, username=username, password=password, nickname=nickname, email=email)
        self.assert_json(self.post(url, params.replace(token='')), 0)
        self.assert_json(self.post(url, params), 1)
        # Make sure the credentials have not changed yet
        self.assertEqual(db.query(User).filter_by(username=username, nickname=nickname, email=email).count(), 0)
        # Make sure the credentials have changed after confirmation
        self.confirm_ticket(email)
        self.assertEqual(db.query(User).filter_by(username=username, nickname=nickname, email=email).first().check(password), True)
        # Use all available tickets
        TICKET_LEN = users.TICKET_LEN 
        users.TICKET_LEN = 0
        db.merge(User_(ticket=''))
        db.flush()
        user = db.query(User).filter_by(email=email).first()
        data = users.save_user_(DummyRequest(), params, 'update', user)
        self.assertEqual(data['isOk'], 0)
        users.TICKET_LEN = TICKET_LEN

    @unittest.skipIf(not settings.get('sms.imap.host'), 'not configured')
    def test_update_smsAddress(self):
        'Make sure that updating smsAddresses works'
        url = self.get_url('user_update')
        db.query(SMSAddress).delete()
        userL_code = db.query(User.code).filter_by(id=self.userL['id']).first()[0]
        userM_code = db.query(User.code).filter_by(id=self.userM['id']).first()[0]
        userS_code = db.query(User.code).filter_by(id=self.userS['id']).first()[0]

        # Test sms.connect()
        self.assertRaises(ApplicationError, sms.connect, {})
        self.assertRaises(ApplicationError, sms.connect, dict(self.settings.items() + 
            [('sms.imap.host', 'x' + self.settings['sms.imap.host'])]))
        # Connect to IMAP server
        imapServer = sms.connect(self.settings)
        def register_smsAddress(userID, userCode, userEmail):
            imapServer.revive('inbox', imapIO.build_message(
                subject='%s-%s' % (userID, userCode), 
                fromWhom='sms_' + userEmail))
        # Register an invalid email address
        register_smsAddress(self.userL['id'], userL_code, '')
        # Register using an invalid userID or userCode
        register_smsAddress(-1, userL_code, self.userL['email'])
        register_smsAddress(self.userL['id'], -1, self.userL['email'])
        # Register three email addresses
        register_smsAddress(self.userL['id'], userL_code, self.userL['email'])
        register_smsAddress(self.userM['id'], userM_code, self.userM['email'])
        register_smsAddress(self.userS['id'], userS_code, self.userS['email'])
        # Register an address that already exists for the given user
        register_smsAddress(self.userL['id'], userL_code, self.userL['email'])
        # Remove an email address
        register_smsAddress(0, 'xxx', self.userL['email'])
        # Process
        sms.process(self.settings)
        # Make sure we only have two registered SMS address
        self.assertEqual(2, db.query(SMSAddress).count())
        smsAddressA = db.query(SMSAddress).filter_by(user_id=self.userM['id']).first()
        smsAddressI = db.query(SMSAddress).filter_by(user_id=self.userS['id']).first()

        # Get token
        self.login(self.userS)
        token = get_token(self.get(url).unicode_body)

        params = ReplaceableDict(token=token, id=smsAddressI.id, is_active=1)
        # Activate an smsAddress that doesn't belong to the user
        self.assert_json(self.post(url, params.replace(id=smsAddressA.id)), 0)
        # Activate an smsAddress
        self.assert_json(self.post(url, params), 1)
        self.assertEqual(db.query(SMSAddress.is_active).filter_by(user_id=self.userS['id']).first()[0], True)

        params = ReplaceableDict(token=token, id=smsAddressI.id, is_active=0)
        # Deactivate an smsAddress that doesn't belong to the user
        self.assert_json(self.post(url, params.replace(id=smsAddressA.id)), 0)
        # Deactivate an smsAddress
        self.assert_json(self.post(url, params), 1)
        self.assertEqual(db.query(SMSAddress.is_active).filter_by(user_id=self.userS['id']).first()[0], False)

        params = ReplaceableDict(token=token, id=smsAddressI.id)
        # Remove an smsAddress that doesn't belong to the user
        self.assert_json(self.post(url, params.replace(id=smsAddressA.id)), 0)
        # Remove an smsAddress that belongs to the user
        self.assert_json(self.post(url, params), 1)
        self.assertEqual(db.query(SMSAddress).filter_by(id=smsAddressI.id).count(), 0)

    def test_move(self):
        'Make sure that only leaders can promote or demote other users'
        url = self.get_url('user_move')
        # Check that we only see the login page if the user is not logged in
        self.assert_forbidden(url, method='POST')
        # Check that only leaders can promote or demote other users
        for userD in [self.userM, self.userS]:
            self.login(userD)
            self.assert_forbidden(url, method='POST')

        self.login(self.userL)
        userID = self.userL['id']
        token = get_token(self.get(self.get_url('user_index')).body)
        get_targetUser = lambda: db.query(User).filter_by(id=self.userS['id']).first()
        targetUser = get_targetUser()
        params = ReplaceableDict(token=token, id=targetUser.id, role=ROLE_LEADER)
        # Check that a bad token fails
        self.assert_json(self.post(url, params.replace(token=token + 'x')), 0)
        # Check that a bad id fails
        self.assert_json(self.post(url, params.replace(id=0)), 0)
        # Check that a bad role fails
        self.assert_json(self.post(url, params.replace(role='xxx')), 0)
        # Check that a missing role fails
        self.assert_json(self.post(url, params.hide('role')), 0)
        # Check that a leader cannot promote or demote self
        self.assert_json(self.post(url, params.replace(id=userID)), 0)
        # Check that a leader can promote or demote other users
        self.assert_json(self.post(url, params.replace(role=ROLE_LEADER)), 1)
        targetUser = get_targetUser()
        self.assertEqual(targetUser.role, ROLE_LEADER)
        self.assert_json(self.post(url, params.replace(role=ROLE_MEMBER)), 1)
        targetUser = get_targetUser()
        self.assertEqual(targetUser.role, ROLE_MEMBER)
        self.assert_json(self.post(url, params.replace(role=ROLE_SPECTATOR)), 1)
        targetUser = get_targetUser()
        self.assertEqual(targetUser.role, ROLE_SPECTATOR)

    def test_mutate(self):
        'Make sure that mutating the user works'
        url = self.get_url('user_mutate')
        self.login(self.userS)
        token = get_token(self.get(self.get_url('user_update')).body)
        params = ReplaceableDict(token=token)
        # Check that a bad token fails
        self.assert_json(self.post(url, params.replace(token=token + 'x')), 0)
        # Check that we can mutate the user code
        userCode = db.query(User.code).filter_by(id=self.userS['id']).first()[0]
        self.assert_json(self.post(url, params), 1)
        self.assertNotEqual(userCode, db.query(User.code).filter_by(id=self.userS['id']).first()[0])

    def test_reset(self):
        'Make sure that resetting the password works'
        url = self.get_url('user_reset')
        password, email = [self.userS[x] for x in 'password', 'email']
        # Trying to reset an email that does not exist returns an error
        self.assert_json(self.post(url, dict(email=email + 'x')), 0)
        # Resetting the password does not immediately change the password
        self.assert_json(self.post(url, dict(email=email.upper())), 1)
        self.assertEqual(db.query(User).filter_by(email=email).first().check(password), True)
        # Apply change
        self.confirm_ticket(email)
        self.assertEqual(db.query(User).filter_by(email=email).first().check(password), False)

    def confirm_ticket(self, email):
        'Confirm account update ticket'
        query = db.query(User_.ticket).order_by(User_.when_expire.desc())
        ticket = query.filter_by(email=email).first()[0]
        self.get(self.get_url('user_confirm', ticket=ticket))
