'Pyramid WSGI configuration'
import os
import ConfigParser
import logging; log = logging.getLogger(__name__)
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from pyramid.config import Configurator
from pyramid.events import BeforeRender
from pyramid.httpexceptions import HTTPFound
from pyramid.response import Response
from pyramid.security import Everyone, Authenticated, Allow, Deny, ALL_PERMISSIONS, authenticated_userid
from pyramid_beaker import session_factory_from_settings, set_cache_regions_from_settings
from whenIO import WhenIO

from {{package}}.libraries import tools
from {{package}}.models import initialize_sql, ApplicationError
from {{package}}.views import users, rows
from {{package}}.parameters import *


robots_txt = """\
User-agent: *
Disallow: /
"""


def main(global_config, **settings):
    'Return a Pyramid WSGI application'
    settings.update({ 
        'mako.default_filters': 'h',
        'mako.directories': '{{package}}:templates',
        'cache.regions': 'short, medium, long',
    })
    # Load sensitive configuration
    if '__file__' in global_config:
        settings.update(load_sensitive_settings(global_config['__file__'], global_config))
    if 'ciphers.secret' in settings:
        tools.secret = settings['ciphers.secret']
    try:
        os.makedirs(os.path.dirname(settings['mail.queue_path']))
    except OSError: # pragma: no cover
        pass
    # Connect to database
    initialize_sql(settings)
    # Define methods
    def get_groups(userID, request):
        'Define server-side permissions associated with the user'
        # Unpack properties
        try:
            code, is_member, is_leader = users.unpack_properties(userID, 'code', 'is_member', 'is_leader')
        except TypeError:
            return ['outcast']
        # Check code
        identity = authenticationPolicy.cookie.identify(request)
        if code != users.parse_tokens(identity['tokens'])[0]:
            return ['outcast']
        # Get groups
        groups = []
        if is_member:
            groups.append('member')
        if is_leader:
            groups.append('leader')
        return groups
    def add_renderer_globals(event):
        'Define client-side permissions associated with user'
        request = event._system['request']
        userID = authenticated_userid(request)
        groups = get_groups(userID, request)
        if 'outcast' not in groups:
            nickname, minutes_offset = users.unpack_properties(userID, 'nickname', 'minutes_offset')
        else:
            userID = None
            nickname, minutes_offset = u'', MINUTES_OFFSET
        event.update(dict(
            SITE_NAME=SITE_NAME,
            SITE_VERSION=SITE_VERSION,
            USER_ID=userID,
            USER_NICKNAME=nickname,
            USER_WHENIO=WhenIO(minutes_offset),
            IS_MEMBER='member' in groups,
            IS_LEADER='leader' in groups))
    # Prepare configuration
    if not settings.get('authtkt.secret'):
        settings['authtkt.secret'] = os.urandom(SECRET_LEN)
    authenticationPolicy = AuthTktAuthenticationPolicy(settings['authtkt.secret'], 
        callback=get_groups, http_only=True)
    config = Configurator(
        settings=settings,
        authentication_policy=authenticationPolicy,
        authorization_policy=ACLAuthorizationPolicy(),
        root_factory='{{package}}.RootFactory')
    config.add_subscriber(add_renderer_globals, BeforeRender)
    # Configure transaction manager and mailer
    config.include('pyramid_tm')
    config.include('pyramid_mailer')
    # Configure sessions and caching
    if not settings.get('session.secret'):
        settings['session.secret'] = os.urandom(SECRET_LEN)
    config.set_session_factory(session_factory_from_settings(settings))
    set_cache_regions_from_settings(settings)
    # Configure static assets
    config.add_static_view('static', '{{package}}:static')
    config.add_view(lambda request: Response(content_type='text/plain', body=robots_txt), name='robots.txt', permission='__no_permission_required__')
    # Configure routes for user account management
    config.include(users)

    # Configure routes that demonstrate a row-based interface
    config.include(rows)
    # Redirect homepage
    config.add_view(lambda request: HTTPFound(location=request.route_path('row_index')), name='', permission='__no_permission_required__')

    # Return WSGI app
    return config.make_wsgi_app()


def load_settings(configurationPath, basePath):
    'Load settings'
    defaultByKey = {'here': basePath}
    configParser = ConfigParser.ConfigParser(defaultByKey)
    if not configParser.read(configurationPath):
        raise ApplicationError('Could not open %s' % configurationPath)
    settings = {}
    for key, value in configParser.items('app:{{project}}'):
        if 'use' == key:
            if value.startswith('config:'):
                settings.update(load_settings(value.replace('config:', ''), basePath))
        settings[key] = value
    settings.update(load_sensitive_settings(configurationPath, defaultByKey))
    return settings


def load_sensitive_settings(configurationPath, defaultByKey):
    'Load sensitive settings from hidden configuration file'
    configFolder, configName = os.path.split(configurationPath)
    sensitivePath = os.path.join(configFolder, '.' + configName)
    settings = {}
    configParser  = ConfigParser.ConfigParser(defaultByKey)
    if not configParser.read(sensitivePath):
        log.warn('Could not open %s' % sensitivePath)
    for section in configParser.sections():
        settings.update(configParser.items(section))
    return settings


class RootFactory(object):
    'Permission definitions'
    __acl__ = [ 
        (Deny, 'outcast', ALL_PERMISSIONS),
        (Allow, Everyone, 'user_index'),
        (Allow, Everyone, 'user_register'),
        (Allow, Authenticated, 'user_update'),
        (Allow, Authenticated, 'user_mutate'),
        (Allow, 'leader', 'user_move'),
        (Allow, Everyone, 'row_index'),
        (Allow, 'member', 'row_update'),
    ]

    def __init__(self, request):
        pass
