'Pyramid WSGI configuration'
import os
import ConfigParser
import logging; log = logging.getLogger(__name__)
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from pyramid.security import Everyone, Authenticated, Allow, Deny, ALL_PERMISSIONS, authenticated_userid
from pyramid.httpexceptions import HTTPFound
from pyramid.config import Configurator
from pyramid.response import Response
from pyramid_beaker import session_factory_from_settings, set_cache_regions_from_settings
from whenIO import WhenIO

from {{package}}.libraries import tools
from {{package}}.models import initialize_sql, ApplicationError, ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER
from {{package}}.views import users, rows
from {{package}}.parameters import *


robots_txt = """\
User-agent: *
Disallow: /
"""


def main(global_config, **settings):
    'Return a Pyramid WSGI application'
    settings.update({ 
        'mako.default_filters': 'h',
        'mako.directories': '{{package}}:templates',
        'cache.regions': 'short, medium, long',
    })
    # Load sensitive configuration
    if '__file__' in global_config:
        settings.update(load_sensitive_settings(global_config['__file__'], global_config))
    if 'ciphers.secret' in settings:
        tools.secret = settings['ciphers.secret']
    # Connect to database
    initialize_sql(settings)
    # Define methods
    def get_groups(userID, request):
        'Define server-side permissions associated with the user'
        # Unpack properties
        try:
            code, role = users.unpack_properties(userID, 'code', 'role')
        except TypeError:
            return ['outcast']
        # Check code
        identity = authenticationPolicy.cookie.identify(request)
        if code != users.parse_tokens(identity['tokens'])[0]:
            return ['outcast']
        # Get groups
        groups = []
        if role >= ROLE_MEMBER:
            groups.append('member')
            if role >= ROLE_LEADER:
                groups.append('leader')
        return groups
    def make_renderer_globals(system):
        'Define client-side permissions associated with user'
        request = system['request']
        userID = authenticated_userid(request)
        groups = get_groups(userID, request)
        if 'outcast' not in groups:
            nickname, minutes_offset = users.unpack_properties(userID, 'nickname', 'minutes_offset')
        else:
            userID = None
            nickname, minutes_offset = u'', MINUTES_OFFSET
        return dict(
            SITE_NAME=SITE_NAME,
            SITE_VERSION=SITE_VERSION,
            USER_ID=userID,
            USER_NICKNAME=nickname,
            USER_WHENIO=WhenIO(minutes_offset),
            IS_MEMBER='member' in groups,
            IS_LEADER='leader' in groups)
    # Prepare configuration
    if not settings.get('authtkt.secret'):
        settings['authtkt.secret'] = os.urandom(SECRET_LEN)
    authenticationPolicy = AuthTktAuthenticationPolicy(settings['authtkt.secret'], 
        callback=get_groups, http_only=True)
    config = Configurator(
        settings=settings,
        authentication_policy=authenticationPolicy,
        authorization_policy=ACLAuthorizationPolicy(),
        renderer_globals_factory=make_renderer_globals,
        root_factory='{{package}}.RootFactory')
    # Configure transaction manager and mailer
    config.include('pyramid_tm')
    config.include('pyramid_mailer')
    # Configure sessions and caching
    if not settings.get('session.secret'):
        settings['session.secret'] = os.urandom(SECRET_LEN)
    config.set_session_factory(session_factory_from_settings(settings))
    set_cache_regions_from_settings(settings)
    # Configure static assets
    config.add_static_view('static', '{{package}}:static')
    config.add_view(lambda request: Response(content_type='text/plain', body=robots_txt), name='robots.txt', permission='__no_permission_required__')
    # Configure routes for user account management
    config.include(users)

    # Configure routes that demonstrate a row-based interface
    config.include(rows)
    # Redirect homepage
    config.add_view(lambda request: HTTPFound(location=request.route_path('row_index')), name='', permission='__no_permission_required__')

    # Return WSGI app
    return config.make_wsgi_app()


def load_settings(configurationPath, basePath):
    'Load settings'
    defaultByKey = {'here': basePath}
    configParser = ConfigParser.ConfigParser(defaultByKey)
    if not configParser.read(configurationPath):
        raise ApplicationError('Could not open %s' % configurationPath)
    settings = {}
    for key, value in configParser.items('app:{{project}}'):
        if 'use' == key:
            if value.startswith('config:'):
                settings.update(load_settings(value.replace('config:', ''), basePath))
        settings[key] = value
    settings.update(load_sensitive_settings(configurationPath, defaultByKey))
    return settings


def load_sensitive_settings(configurationPath, defaultByKey):
    'Load sensitive settings from hidden configuration file'
    configFolder, configName = os.path.split(configurationPath)
    sensitivePath = os.path.join(configFolder, '.' + configName)
    settings = {}
    configParser  = ConfigParser.ConfigParser(defaultByKey)
    if not configParser.read(sensitivePath):
        log.warn('Could not open %s' % sensitivePath)
    for section in configParser.sections():
        settings.update(configParser.items(section))
    return settings


class RootFactory(object):
    'Permission definitions'
    __acl__ = [ 
        (Deny, 'outcast', ALL_PERMISSIONS),
        (Allow, Everyone, 'user_index'),
        (Allow, Everyone, 'user_register'),
        (Allow, Authenticated, 'user_update'),
        (Allow, Authenticated, 'user_mutate'),
        (Allow, 'leader', 'user_move'),
        (Allow, Everyone, 'row_index'),
        (Allow, 'member', 'row_update'),
    ]

    def __init__(self, request):
        pass
