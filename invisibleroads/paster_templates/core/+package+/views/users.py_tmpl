'Views for user account management'
import datetime
from pyramid.view import view_config
from pyramid.security import remember, forget, authenticated_userid
from pyramid.httpexceptions import HTTPFound
from pyramid.renderers import render
from pyramid.security import NO_PERMISSION_REQUIRED
from pyramid_mailer import get_mailer
from pyramid_mailer.message import Message
from email.utils import formataddr
from formencode import validators, Schema, All, Invalid
from recaptcha.client import captcha
from sqlalchemy.orm import joinedload
from beaker.cache import cache_region, region_invalidate

from {{package}}.models import db, User, User_, SMSAddress, ApplicationError, Unique, ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER
from {{package}}.libraries.tools import make_random_string, make_random_unique_string, get_remote_ip
from {{package}}.parameters import *


def includeme(config):
    config.scan(__name__)
    config.add_route('user_index', '')
    config.add_route('user_register', 'register')
    config.add_route('user_confirm', 'confirm/{ticket}')
    config.add_route('user_login', 'login')
    config.add_route('user_logout', 'logout')
    config.add_route('user_update', 'update')
    config.add_route('user_mutate', 'mutate')
    config.add_route('user_reset', 'reset')
    config.add_route('user_move', 'move')


@view_config(route_name='user_index', renderer='users/index.mako', permission='user_index')
def index(request):
    'List users'
    return dict(users=db.query(User).order_by(User.when_login.desc()).all())


@view_config(route_name='user_register', renderer='users/change.mako', request_method='GET', permission='user_register')
def register(request):
    'Show account registration page'
    return dict(user=None)


@view_config(route_name='user_register', renderer='json', request_method='POST', permission='user_register')
def register_(request):
    'Store proposed changes and send confirmation email'
    return save_user_(request, dict(request.params), 'registration')


@view_config(route_name='user_confirm', permission=NO_PERMISSION_REQUIRED)
def confirm(request):
    'Confirm changes'
    # Apply changes to user account
    try:
        user_ = apply_user_(request)
    except ApplicationError:
        message = 'Ticket expired'
    else:
        message = 'Account updated' if user_.user_id else 'Account created'
        # Delete expired or similar user_
        db.execute(User_.__table__.delete().where(
            (User_.when_expire < datetime.datetime.utcnow()) | 
            (User_.username == user_.username) | 
            (User_.nickname == user_.nickname) | 
            (User_.email == user_.email)))
    # Save message in session
    request.session.flash(message)
    return HTTPFound(location=request.route_path('user_login'))


@view_config(route_name='user_login', renderer='users/login.mako', request_method='GET', permission=NO_PERMISSION_REQUIRED)
@view_config(renderer='users/login.mako', context='pyramid.exceptions.Forbidden', permission=NO_PERMISSION_REQUIRED)
def login(request):
    'Show login form'
    # If the user accessed the login page directly,
    if request.path == request.route_path('user_login'):
        # Get the target url from the query string
        url = request.params.get('url', '/')
    # If the user tried to access a forbidden resource,
    else:
        # Get the target url directly
        url = request.url
    return dict(url=url, REJECTION_LIMIT=REJECTION_LIMIT)


@view_config(route_name='user_login', renderer='json', request_method='POST', permission=NO_PERMISSION_REQUIRED)
def login_(request):
    'Process login credentials'
    # Make shortcuts
    environ, params, registry = [getattr(request, x) for x in 'environ', 'params', 'registry']
    username, password = [params.get(x, '').strip() for x in 'username', 'password']
    if not username or not password:
        return dict(isOk=0)
    # Check username
    user = db.query(User).filter_by(username=username).first()
    if not user:
        return dict(isOk=0)
    # If the password is incorrect, increment and return user.rejection_count
    if not user.check(password):
        user.rejection_count += 1
        return dict(isOk=0, rejectionCount=user.rejection_count)
    # If there have been too many rejections, expect recaptcha
    if user.rejection_count >= REJECTION_LIMIT:
        rChallenge, rResponse = [params.get(x, '') for x in 'recaptcha_challenge', 'recaptcha_response']
        rPrivate = registry.settings.get('recaptcha.private', '')
        clientIP = environ.get('HTTP_X_REAL_IP', environ.get('HTTP_X_FORWARDED_FOR', environ.get('REMOTE_ADDR')))
        # If the response is not valid, say so
        if not captcha.submit(rChallenge, rResponse, rPrivate, clientIP).is_valid:
            return dict(isOk=0, rejectionCount=user.rejection_count)
    # Save user
    try:
        user.timezone_offset = int(params.get('timezoneOffset', TIMEZONE_OFFSET_MINUTES))
    except ValueError:
        user.timezone_offset = TIMEZONE_OFFSET_MINUTES
    user.when_login = datetime.datetime.utcnow()
    user.rejection_count = 0
    # Set cookie
    request.response.headerlist.extend(remember(request, user.id, tokens=format_tokens(user)))
    return dict(isOk=1)


@view_config(route_name='user_logout', permission=NO_PERMISSION_REQUIRED)
def logout(request):
    'Logout'
    return HTTPFound(location=request.params.get('url', '/'), headers=forget(request))


@view_config(route_name='user_update', renderer='users/change.mako', request_method='GET', permission='user_update')
def update(request):
    'Show account update page'
    userID = authenticated_userid(request)
    user = db.query(User).options(joinedload(User.sms_addresses)).get(userID)
    return dict(user=user)


@view_config(route_name='user_update', renderer='json', request_method='POST', permission='user_update')
def update_(request):
    'Update account'
    params = request.params
    if params.get('token') != request.session.get_csrf_token():
        return dict(isOk=0, message='Invalid session token')
    userID = authenticated_userid(request)
    # If the user is trying to update account information, send confirmation email
    if 'username' in params:
        return save_user_(request, dict(params), 'update', db.query(User).get(userID))
    # Make sure the smsAddressID belongs to the user
    smsAddressID = params.get('id')
    smsAddress = db.query(SMSAddress).filter(
        (SMSAddress.id == smsAddressID) & 
        (SMSAddress.user_id == userID)).first()
    if not smsAddress:
        return dict(isOk=0, message='Could not find smsAddressID=%s for userID=%s' % (smsAddressID, userID))
    # Load
    try:
        is_active = int(params.get('is_active'))
    except (TypeError, ValueError):
        is_active = None
    # If the user is activating or deactivating an SMS address,
    if is_active is not None:
        smsAddress.is_active = is_active
    # If the user is removing an SMS address,
    else:
        db.delete(smsAddress)
    return dict(isOk=1, content=render('users/smsAddresses.mako', update(request), request))


@view_config(route_name='user_mutate', renderer='json', request_method='POST', permission='user_mutate')
def mutate(request):
    'Mutate user token'
    params = request.params
    if params.get('token') != request.session.get_csrf_token():
        return dict(isOk=0, message='Invalid session token')
    userID = authenticated_userid(request)
    # Mutate user code 
    user = db.query(User).get(userID)
    user.code = make_random_string(CODE_LEN)
    # Refresh cookie
    request.response.headerlist.extend(remember(request, user.id, tokens=format_tokens(user)))
    # Invalidate cache
    region_invalidate(get_properties, None, userID)
    return dict(isOk=1, code=user.code)


@view_config(route_name='user_reset', renderer='json', request_method='POST', permission=NO_PERMISSION_REQUIRED)
def reset(request):
    'Reset password'
    # Get email
    email = request.params.get('email')
    # Try to load the user
    user = db.query(User).filter(User.email==email).first()
    # If the email is not in our database,
    if not user: 
        return dict(isOk=0)
    # Reset account
    return save_user_(request, dict(
        username=user.username, 
        password=make_random_string(PASSWORD_LEN_MAX),
        nickname=user.nickname,
        email=user.email), 'reset', user)


@view_config(route_name='user_move', renderer='json', request_method='POST', permission='user_move')
def move(request):
    'Move a user to a different role'
    params = request.params
    if params.get('token') != request.session.get_csrf_token():
        return dict(isOk=0, message='Invalid session token')
    userID = authenticated_userid(request)
    # Load targetUser
    targetUserID = params.get('id', 0)
    targetUser = db.query(User).get(targetUserID)
    if not targetUser:
        return dict(isOk=0, message='Could not find targetUserID=%s' % targetUserID)
    if int(userID) == int(targetUserID):
        return dict(isOk=0, message='Cannot change your own role')
    # Load role
    value = params.get('role')
    try:
        value = int(value)
    except (TypeError, ValueError):
        return dict(isOk=0, message='Could not parse role=%s' % value)
    # If it is a promotion,
    if value > targetUser.role:
        if ROLE_MEMBER == value:
            verb = 'activated'
            adjective = 'member'
        elif ROLE_LEADER == value:
            verb = 'promoted'
            adjective = 'leader'
        get_mailer(request).send_to_queue(Message(
            recipients=[formataddr((targetUser.nickname, targetUser.email))],
            subject='Account ' + verb,
            body='Your account at %s now has %s privileges.' % (request.application_url, adjective)))
    targetUser.role = value
    # Invalidate cache
    region_invalidate(get_properties, None, targetUserID)
    return dict(isOk=1, content=render('users/users.mako', index(request), request))


def format_tokens(user):
    'Format user information into a cookie'
    code = 'x' + str(user.code)
    return [code]


def parse_tokens(tokens):
    'Parse user information from a cookie'
    # Due to paste.auth.auth_tkt.parse_ticket(), len(tokens) >= 1
    code = tokens[0][1:]
    return [code]


@cache_region('medium')
def get_properties(userID):
    'Return user properties as a tuple to save cache space'
    return db.query(User.nickname, User.timezone_offset, User.is_member, User.is_leader, User.code).filter_by(id=userID).first()


def unpack_properties(userID, *names):
    'Unpack properties corresponding to userID as specified by names'
    properties = get_properties(userID)
    propertyNames = ['nickname', 'timezoneOffset', 'isMember', 'isLeader', 'code']
    return [properties[propertyNames.index(x)] for x in names]


def save_user_(request, valueByName, action, user=None):
    'Validate values and send confirmation email if values are okay'
    # Validate form
    try:
        form = UserForm().to_python(valueByName, user)
    except Invalid, error:
        return dict(isOk=0, errorByID=error.unpack_errors())
    # Prepare ticket
    try:
        ticket = make_random_unique_string(TICKET_LEN, 
            lambda x: db.query(User_).filter_by(ticket=x).first() == None)
    except RuntimeError:
        return dict(isOk=0, errorByID={'status': 'Could not generate ticket; please try again later'})
    # Prepare user_
    user_ = User_(
        username=form['username'],
        password=form['password'], 
        nickname=form['nickname'], 
        email=form['email'],
        user_id=user.id if user else None,
        ticket=ticket,
        when_expire=datetime.datetime.utcnow() + datetime.timedelta(hours=TICKET_LIFE_HOURS))
    db.add(user_)
    # Send confirmation email
    get_mailer(request).send_to_queue(Message(
        recipients=[formataddr((user_.nickname, user_.email))],
        subject='Confirm ' + action,
        body=render('users/confirm.mako', dict(
            form=form,
            action=action,
            ticket=ticket,
            TICKET_LIFE_HOURS=TICKET_LIFE_HOURS,
        ), request)))
    return dict(isOk=1)


def apply_user_(request):
    'Finalize a change to a user account'
    ticket = request.matchdict.get('ticket', '')
    if not ticket:
        raise ApplicationError
    user_ = db.query(User_).filter(
        (User_.ticket == ticket) & 
        (User_.when_expire >= datetime.datetime.utcnow())).first()
    if not user_:
        raise ApplicationError
    # If the ticket is valid,
    if user_:
        # Apply the change and reset user.rejection_count
        userID = user_.user_id
        user = User(
            id=userID,
            username=user_.username,
            password_=user_.password_,
            nickname=user_.nickname,
            email=user_.email,
            rejection_count=0,
            code=make_random_string(CODE_LEN))
        db.merge(user)
        # If we have a new user requiring activation, notify leaders
        if not userID:
            leaderQuery = db.query(User).filter(User.role==ROLE_LEADER)
            get_mailer(request).send_to_queue(Message(
                recipients=[formataddr((x.nickname, x.email)) for x in leaderQuery],
                subject='Activate %s?' % user.nickname,
                body=render('users/activate.mako', dict(
                    user=user_,
                    browser=request.user_agent,
                    ip=get_remote_ip(request),
                ), request)))
        # Invalidate cache
        region_invalidate(get_properties, None, userID)
    return user_


class SecurePassword(validators.FancyValidator):
    'Validator to prevent weak passwords'

    def _to_python(self, value, user):
        'Check whether a password is strong enough'
        if len(set(value)) < 6:
            raise Invalid('That password needs more variety', value, user)
        return value


class UserForm(Schema):
    'User account validator'

    allow_extra_fields = True
    filter_extra_fields = True

    username = All(
        validators.UnicodeString(
            min=USERNAME_LEN_MIN,
            max=USERNAME_LEN_MAX,
            not_empty=True,
            strip=True),
        Unique(User, 'username', 'That username already exists'))
    password = All(
        validators.UnicodeString(
            min=PASSWORD_LEN_MIN,
            not_empty=True),
        SecurePassword())
    nickname = All(
        validators.UnicodeString(
            min=NICKNAME_LEN_MIN,
            max=NICKNAME_LEN_MAX,
            not_empty=True,
            strip=True),
        Unique(User, 'nickname', 'That nickname already exists'))
    email = All(
        validators.UnicodeString(
            max=EMAIL_LEN_MAX,
            not_empty=True,
            strip=True),
        validators.Email(),
        Unique(User, 'email', 'That email is reserved for another account'))
