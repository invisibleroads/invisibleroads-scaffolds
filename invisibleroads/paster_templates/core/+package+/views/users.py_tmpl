'Views for user account management'
import datetime
from beaker.cache import region_invalidate
from email.utils import formataddr
from formencode import Schema, All, Invalid
from formencode.validators import StringBool, Email, FancyValidator, Int, UnicodeString
from pyramid.httpexceptions import HTTPFound
from pyramid.renderers import render
from pyramid.security import remember, forget, authenticated_userid, NO_PERMISSION_REQUIRED
from pyramid.view import view_config
from pyramid_mailer import get_mailer
from pyramid_mailer.message import Message
from recaptcha.client import captcha
from sqlalchemy.orm import joinedload

from {{package}}.libraries.tools import make_random_string, make_random_unique_string, get_remote_ip, make_int
from {{package}}.models import User, User_, SMSAddress, ApplicationError, db, ROLE_LEADER, ROLE_MEMBER, ROLE_SPECTATOR
from {{package}}.parameters import *
from {{package}}.validators import UsersCannotChangeOwn, FormState, IDExists, IDExistsAndBelongsToUser, Unique


def includeme(config):
    config.scan(__name__)
    config.add_route('user_index', 'users')
    config.add_route('user_json', 'users.json')
    config.add_route('user_register', 'users/register')
    config.add_route('user_confirm', 'users/confirm/{ticket}')
    config.add_route('user_login', 'users/login')
    config.add_route('user_logout', 'users/logout')
    config.add_route('user_update', 'users/update')
    config.add_route('user_mutate', 'users/mutate')
    config.add_route('user_reset', 'users/reset')
    config.add_route('user_move', 'users/move')


@view_config(route_name='user_index', renderer='users/index.mako', permission='user_index')
def index(request):
    'List users'
    return dict(users=db.query(User).order_by(User.when_login.desc()).all())


@view_config(route_name='user_json', renderer='json', permission='user_index')
def json(request):
    'List users in JSON format'
    return dict(isOk=1, items=db.query(User.id, User.nickname).all())


@view_config(route_name='user_register', renderer='users/change.mako', request_method='GET', permission='user_register')
def register(request):
    'Show account registration page'
    return dict(user=None)


@view_config(route_name='user_register', renderer='json', request_method='POST', permission='user_register')
def register_(request):
    'Store proposed changes and send confirmation email'
    return save_user_(request, dict(request.params), 'registration', userID=None)


@view_config(route_name='user_confirm', permission=NO_PERMISSION_REQUIRED)
def confirm(request):
    'Confirm changes'
    # Apply changes to user account
    try:
        user_ = apply_user_(request)
    except ApplicationError:
        message = 'Ticket expired'
    else:
        message = 'Account updated' if user_.user_id else 'Account created'
        # Delete expired or similar user_
        db.execute(User_.__table__.delete().where(
            (User_.when_expire < datetime.datetime.utcnow()) | 
            (User_.username == user_.username) | 
            (User_.nickname == user_.nickname) |
            (User_.email == user_.email)))
    # Save message in session
    request.session.flash(message)
    return HTTPFound(location=request.route_path('user_login'), headers=forget(request))


@view_config(route_name='user_login', renderer='users/login.mako', request_method='GET', permission=NO_PERMISSION_REQUIRED)
@view_config(renderer='users/login.mako', context='pyramid.exceptions.Forbidden', permission=NO_PERMISSION_REQUIRED)
def login(request):
    'Show login form'
    # If the user accessed the login page directly,
    if request.path == request.route_path('user_login'):
        # Get the target url from the query string
        url = request.params.get('url', '/')
    # If the user tried to access a forbidden resource,
    else:
        # Get the target url directly
        url = request.url
    return dict(url=url, REJECTION_LIMIT=REJECTION_LIMIT)


@view_config(route_name='user_login', renderer='json', request_method='POST', permission=NO_PERMISSION_REQUIRED)
def login_(request):
    'Process login credentials'
    # Make shortcuts
    environ, params, registry = [getattr(request, x) for x in 'environ', 'params', 'registry']
    username, password = [params.get(x, u'').strip() for x in 'username', 'password']
    if not username or not password:
        return dict(isOk=0)
    # Check username
    user = db.query(User).filter_by(username=username).first()
    if not user:
        return dict(isOk=0)
    # If the password is incorrect, increment and return user.rejection_count
    if not user.check(password):
        user.rejection_count += 1
        return dict(isOk=0, rejectionCount=user.rejection_count)
    # If there have been too many rejections, expect recaptcha
    if user.rejection_count >= REJECTION_LIMIT:
        rChallenge, rResponse = [params.get(x, u'') for x in 'recaptcha_challenge', 'recaptcha_response']
        rPrivate = registry.settings.get('recaptcha.private', '')
        clientIP = environ.get('HTTP_X_REAL_IP', environ.get('HTTP_X_FORWARDED_FOR', environ.get('REMOTE_ADDR')))
        # If the response is not valid, say so
        if not captcha.submit(rChallenge, rResponse, rPrivate, clientIP).is_valid:
            return dict(isOk=0, rejectionCount=user.rejection_count)
    # Save user
    user.timezone_offset = make_int(params.get('timezoneOffset'), default=TIMEZONE_OFFSET_MINUTES)
    user.when_login = datetime.datetime.utcnow()
    user.rejection_count = 0
    # Set cookie
    request.response.headerlist.extend(remember(request, user.id, tokens=format_tokens(user)))
    return dict(isOk=1)


@view_config(route_name='user_logout', permission=NO_PERMISSION_REQUIRED)
def logout(request):
    'Logout'
    return HTTPFound(location=request.params.get('url', '/'), headers=forget(request))


@view_config(route_name='user_update', renderer='users/change.mako', request_method='GET', permission='user_update')
def update(request):
    'Show account update page'
    userID = authenticated_userid(request)
    user = db.query(User).options(joinedload(User.sms_addresses)).get(userID)
    return dict(user=user)


@view_config(route_name='user_update', renderer='json', request_method='POST', permission='user_update')
def update_(request):
    'Update account'
    params = request.params
    userID = authenticated_userid(request)
    # If the user is trying to update account information, send confirmation email
    if 'username' in params:
        return save_user_(request, dict(params), 'update', userID=userID)
    formState = FormState(userID)
    try:
        form = SMSAddressMoveForm().to_python(dict(params), formState)
    except Invalid, error:
        return dict(isOk=0, message=error.unpack_errors())
    smsAddress = formState.get(SMSAddress, form['id'])
    if form['is_active'] is None:
        db.delete(smsAddress)
    else:
        smsAddress.is_active = form['is_active']
    return dict(isOk=1, content=render('users/smsAddresses.mako', update(request), request))


@view_config(route_name='user_mutate', renderer='json', request_method='POST', permission='user_mutate')
def mutate(request):
    'Mutate user token'
    userID = authenticated_userid(request)
    # Mutate user code 
    user = db.query(User).get(userID)
    user.code = make_random_string(CODE_LEN)
    # Refresh cookie
    request.response.headerlist.extend(remember(request, user.id, tokens=format_tokens(user)))
    # Invalidate cache
    region_invalidate(User.get_properties, None, User, userID)
    return dict(isOk=1, code=user.code)


@view_config(route_name='user_reset', renderer='json', request_method='POST', permission=NO_PERMISSION_REQUIRED)
def reset(request):
    'Reset password'
    email = request.params.get('email', u'')
    user = db.query(User).filter(User.email==email).first()
    # If the email is not in our database,
    if not user:
        return dict(isOk=0)
    # Reset account
    return save_user_(request, dict(
        username=user.username, 
        password=make_random_string(PASSWORD_LEN_MAX),
        nickname=user.nickname,
        email=user.email), 'reset', userID=user.id)


@view_config(route_name='user_move', renderer='json', request_method='POST', permission='user_move')
def move(request):
    'Move a user to a different role'
    params = request.params
    userID = authenticated_userid(request)
    formState = FormState(userID)
    try:
        form = UserMoveForm().to_python(dict(params), formState)
    except Invalid, error:
        return dict(isOk=0, message=error.unpack_errors())
    targetUser = formState.get(User, form['id'])
    targetRole = form['role']
    # If it is a promotion,
    if targetRole > targetUser.role:
        if ROLE_MEMBER == targetRole:
            verb = 'activated'
            adjective = 'member'
        elif ROLE_LEADER == targetRole:
            verb = 'promoted'
            adjective = 'leader'
        get_mailer(request).send_to_queue(Message(
            recipients=[formataddr((targetUser.nickname, targetUser.email))],
            subject='Account ' + verb,
            body='Your account at %s now has %s privileges.' % (request.application_url, adjective)))
    targetUser.role = targetRole
    # Invalidate cache
    region_invalidate(User.get_properties, None, User, form['id'])
    return dict(isOk=1, content=render('users/users.mako', index(request), request))


def format_tokens(user):
    'Format user information into a cookie'
    code = 'x' + str(user.code)
    return [code]


def parse_tokens(tokens):
    'Parse user information from a cookie'
    # Due to paste.auth.auth_tkt.parse_ticket(), len(tokens) >= 1
    code = tokens[0][1:]
    return [code]


def save_user_(request, valueByName, action, userID=None):
    'Validate values and send confirmation email if values are okay'
    try:
        form = UserUpdateForm().to_python(dict(valueByName, id=userID), FormState(userID))
    except Invalid, error:
        return dict(isOk=0, errorByName=error.unpack_errors())
    try:
        ticket = make_random_unique_string(TICKET_LEN, lambda x: not db.query(User_).filter_by(ticket=x).first())
    except RuntimeError: # pragma: no cover
        return dict(isOk=0, errorByName={'status': 'Could not generate ticket; please try again later'})
    db.add(User_(
        username=form['username'],
        password=form['password'], 
        nickname=form['nickname'], 
        email=form['email'],
        user_id=userID,
        ticket=ticket,
        when_expire=datetime.datetime.utcnow() + datetime.timedelta(hours=TICKET_LIFE_HOURS)))
    get_mailer(request).send_to_queue(Message(
        recipients=[formataddr((form['nickname'], form['email']))],
        subject='Confirm ' + action,
        body=render('users/confirm.mako', dict(
            form=form,
            action=action,
            ticket=ticket,
            TICKET_LIFE_HOURS=TICKET_LIFE_HOURS,
        ), request)))
    return dict(isOk=1)


def apply_user_(request):
    'Finalize a change to a user account'
    ticket = request.matchdict.get('ticket', '').strip()
    if not ticket:
        raise ApplicationError
    user_ = db.query(User_).filter((User_.ticket==ticket) & (User_.when_expire>=datetime.datetime.utcnow())).first()
    if not user_:
        raise ApplicationError
    userID = user_.user_id
    user = db.query(User).get(userID) if userID else User()
    user.username = user_.username
    user.password_ = user_.password_
    user.nickname = user_.nickname
    user.email = user_.email
    user.rejection_count = 0 # Reset rejection_count
    user.code = make_random_string(CODE_LEN) # Reset code
    db.add(user)
    # If we have a new user requiring activation, notify leaders
    if not userID:
        mail_users('Activate %s?' % user.nickname, render('users/activate.mako', dict(user=user, browser=request.user_agent, ip=get_remote_ip(request)), request), request, is_leader=True)
    region_invalidate(User.get_properties, None, User, userID)
    return user_


def mail_users(subject, body, request, **userKeywords):
    userQuery = db.query(User)
    if userKeywords:
        userQuery = userQuery.filter_by(**userKeywords)
    users = userQuery.all()
    if users:
        get_mailer(request).send_to_queue(Message(
            recipients=[formataddr((x.nickname, x.email)) for x in users],
            subject=subject, 
            body=body))


class SecurePassword(FancyValidator):

    def _to_python(self, value, user):
        'Check whether a password is strong enough'
        if len(set(value)) < 6:
            raise Invalid('That password needs more variety', value, user)
        return value


class UserUpdateForm(Schema):

    allow_extra_fields = True
    filter_extra_fields = False
    chained_validators = [
        Unique('That username is taken', User, 'username'),
        Unique('That nickname is taken', User, 'nickname'),
        Unique('That email is reserved for another account', User, 'email'),
    ]

    username = UnicodeString(min=USERNAME_LEN_MIN, max=USERNAME_LEN_MAX, not_empty=True, strip=True)
    password = All(UnicodeString(min=PASSWORD_LEN_MIN, not_empty=True), SecurePassword())
    nickname = UnicodeString(min=NICKNAME_LEN_MIN, max=NICKNAME_LEN_MAX, not_empty=True, strip=True)
    email = All(UnicodeString(max=EMAIL_LEN_MAX, not_empty=True, strip=True), Email())


class UserMoveForm(Schema):

    allow_extra_fields = True
    filter_extra_fields = True
    chained_validators = [
        UsersCannotChangeOwn('role', userIDFieldName='id'),
    ]

    id = IDExists(User, min=1, not_empty=True)
    role = Int(not_empty=True, if_missing=ROLE_SPECTATOR)


class SMSAddressMoveForm(Schema):

    allow_extra_fields = True
    filter_extra_fields = True

    id = IDExistsAndBelongsToUser(SMSAddress, min=1, not_empty=True)
    is_active = StringBool(not_empty=True, if_missing=None)
