"""
If the object does not exist in the database, do NOT specify a primary key
with db.add() or db.merge() or you will get a PostgreSQL IntegrityError.
"""
import datetime
import transaction
from beaker.cache import cache_region
from cryptacular import bcrypt
from pyramid.settings import asbool
from sqlalchemy import Column, ForeignKey, Boolean, Integer, String, Unicode, LargeBinary, DateTime, engine_from_config, func
from sqlalchemy.pool import QueuePool, NullPool
from sqlalchemy.orm import scoped_session, sessionmaker, relationship
from sqlalchemy.ext.hybrid import hybrid_property, Comparator
from sqlalchemy.ext.declarative import declarative_base
from zope.sqlalchemy import ZopeTransactionExtension

from {{package}}.libraries.tools import encrypt, decrypt, make_random_string, make_int
from {{package}}.parameters import *


ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER = xrange(3)
crypt = bcrypt.BCRYPTPasswordManager()
db = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))
Base = declarative_base()


class ApplicationError(Exception):
    pass


class CaseInsensitiveUnicode(unicode):

    def __lt__(self, other):
        return self.lower() < other.lower()

    def __le__(self, other):
        return self.lower() <= other.lower()

    def __eq__(self, other):
        return self.lower() == other.lower()

    def __ne__(self, other):
        return self.lower() != other.lower()

    def __gt__(self, other):
        return self.lower() > other.lower()

    def __ge__(self, other):
        return self.lower() >= other.lower()


class CaseInsensitiveComparator(Comparator):

    def operate(self, op, other, **kwargs):
        if hasattr(other, '__iter__'):
            other = [x.lower() for x in other]
        else:
            other = func.lower(other)
        return op(func.lower(self.__clause_element__()), other, **kwargs)


class CaseInsensitiveEncryptComparator(Comparator):

    def operate(self, op, other, **kwargs):
        if hasattr(other, '__iter__'):
            other = [x.lower() for x in other]
        else:
            other = other.lower()
        return op(self.__clause_element__(), encrypt(other), **kwargs)


class EmailMixin(object):
    'Mixin class for a case-insensitive encrypted email address'
    email_ = Column(LargeBinary(EMAIL_LEN_MAX * 2)) # Doubled for unicode addresses
    @hybrid_property
    def email(self):
        return CaseInsensitiveUnicode(decrypt(self.email_))
    @email.setter
    def email(self, email):
        self.email_ = encrypt(email.lower())
    @email.comparator
    def email(Class):
        return CaseInsensitiveEncryptComparator(Class.email_)


class UserMixin(EmailMixin):
    'Mixin class for common user fields'
    username_ = Column(Unicode(USERNAME_LEN_MAX))
    @hybrid_property
    def username(self):
        return CaseInsensitiveUnicode(self.username_)
    @username.setter
    def username(self, username):
        self.username_ = username
    @username.comparator
    def username(Class):
        return CaseInsensitiveComparator(Class.username_)

    password_ = Column(LargeBinary(60))
    @hybrid_property
    def password(self):
        return self.password_
    @password.setter
    def password(self, password):
        self.password_ = crypt.encode(password)

    nickname_ = Column(Unicode(NICKNAME_LEN_MAX))
    @hybrid_property
    def nickname(self):
        return CaseInsensitiveUnicode(self.nickname_)
    @nickname.setter
    def nickname(self, nickname):
        self.nickname_ = nickname
    @nickname.comparator
    def nickname(Class):
        return CaseInsensitiveComparator(Class.nickname_)


class User(Base, UserMixin):
    'A user'
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    role = Column(Integer, default=ROLE_SPECTATOR)
    rejection_count = Column(Integer, default=0)
    timezone_offset = Column(Integer, default=0)
    when_login = Column(DateTime)
    code = Column(String(CODE_LEN), default=lambda: make_random_string(CODE_LEN))
    sms_addresses = relationship('SMSAddress', cascade='all, delete')

    def check(self, password):
        'Return True if we have a matching password'
        return crypt.check(self.password, password)

    @hybrid_property
    def is_member(self):
        return self.role >= ROLE_MEMBER 

    @hybrid_property
    def is_leader(self):
        return self.role >= ROLE_LEADER


class User_(Base, UserMixin):
    'An unconfirmed change to a user account'
    __tablename__ = 'users_'
    id = Column(Integer, primary_key=True)
    user_id = Column(ForeignKey('users.id'))
    ticket = Column(String(TICKET_LEN), unique=True)
    when_expire = Column(DateTime)


class SMSAddress(Base, EmailMixin):
    'An SMS address'
    __tablename__ = 'sms_addresses'
    id = Column(Integer, primary_key=True)
    is_active = Column(Boolean, default=False)
    user_id = Column(ForeignKey('users.id'))


class Row(Base):
    'A row'
    __tablename__ = 'rows'
    id = Column(Integer, primary_key=True)
    user_id = Column(ForeignKey('users.id'))
    user = relationship('User')
    is_active = Column(Boolean, default=False)
    when_update = Column(DateTime, default=datetime.datetime.utcnow)

    col1_ = Column(Unicode(ROW_TEXT_LEN_MAX))
    @hybrid_property
    def col1(self):
        return CaseInsensitiveUnicode(self.col1_)
    @col1.setter
    def col1(self, col1):
        self.col1_ = col1
    @col1.comparator
    def col1(Class):
        return CaseInsensitiveComparator(Class.col1_)

    col2_ = Column(Unicode(ROW_TEXT_LEN_MAX))
    @hybrid_property
    def col2(self):
        return CaseInsensitiveUnicode(self.col2_)
    @col2.setter
    def col2(self, col2):
        self.col2_ = col2
    @col2.comparator
    def col2(Class):
        return CaseInsensitiveComparator(Class.col2_)


def initialize_sql(settings):
    'Create tables and insert data'
    isSQLiteFile = settings['sqlalchemy.url'].startswith('sqlite:///')
    engine = engine_from_config(settings, 'sqlalchemy.', poolclass=NullPool if isSQLiteFile else QueuePool)
    db.configure(bind=engine)
    Base.metadata.bind = engine
    Base.metadata.create_all(engine)
    if not db.query(User.id).first():
        isDebug = is_debug(settings)
        add_users(isDebug)
        transaction.commit()


def is_debug(settings):
    return asbool(settings['pyramid.debug_templates'])


def add_users(isDebug):
    userPacks = [
        (ROLE_LEADER, u'admin'),
    ]
    if isDebug:
        userPacks = [
            (ROLE_LEADER, u'leader'),
            (ROLE_MEMBER, u'member'),
            (ROLE_SPECTATOR, u'spectator'),
        ]
    for role, word in userPacks:
        username = word
        password = word if isDebug else make_random_string(PASSWORD_LEN_MAX)
        print
        print 'Username  ' + username
        print 'Password  ' + password
        db.add(User(
            username=username,
            password=password,
            nickname=word[0].upper() + word[1:],
            email=word + '@example.com',
            role=role))
    print


@cache_region('medium')
def get_user_properties(userID):
    'Return user properties as a tuple instead of a dictionary to save cache space'
    return db.query(
        User.nickname,
        User.timezone_offset,
        User.is_member,
        User.is_leader,
        User.code).filter(User.id==userID).first() if userID else None


def unpack_user_properties(userID, *names):
    'Unpack properties corresponding to userID as specified by names'
    properties = get_user_properties(make_int(userID, default=0)) or [
        u'', 
        TIMEZONE_OFFSET_MINUTES, 
        False, 
        False, 
        u'']
    propertyNames = ['nickname', 'timezoneOffset', 'isMember', 'isLeader', 'code']
    return [properties[propertyNames.index(x)] for x in names]
