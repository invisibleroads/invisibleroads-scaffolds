'Data models'
import transaction
from sqlalchemy import func, Column, ForeignKey, Integer, String, LargeBinary, Unicode, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import column_property, scoped_session, sessionmaker, relationship
from sqlalchemy.orm.properties import ColumnProperty
from sqlalchemy.types import TypeDecorator
from zope.sqlalchemy import ZopeTransactionExtension
from cryptacular import bcrypt

from {{package}}.libraries.tools import encrypt, decrypt, make_random_string
from {{package}}.parameters import *


ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER = xrange(3)
db = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))
Base = declarative_base()
crypt = bcrypt.BCRYPTPasswordManager()


class ApplicationError(Exception):
    'An application error'
    pass


class CaseInsensitiveComparator(ColumnProperty.Comparator):
    'A case-insensitive SQLAlchemy comparator for unicode columns'

    def __eq__(self, other):
        'Return True if the lowercase of both columns are equal'
        return func.lower(self.__clause_element__()) == func.lower(other)


class Encrypted(TypeDecorator):
    """
    An SQLAlchemy type that encrypts on the way in and decrypts on the way out.
    Please note that the encryption first decodes the value into utf-8, 
    which may inflate N unicode characters to N * 2 bytes.
    """

    impl = LargeBinary

    def process_bind_param(self, value, dialect):
        return encrypt(value)

    def process_result_value(self, value, dialect):
        return decrypt(value)


class LowercaseEncrypted(TypeDecorator):
    """
    An SQLAlchemy type that converts the value to lowercase and 
    encrypts on the way in and decrypts on the way out.
    Please note that the encryption first decodes the value into utf-8, 
    which may inflate N unicode characters to N * 2 bytes.
    """

    impl = LargeBinary

    def process_bind_param(self, value, dialect):
        return encrypt((value or '').lower())

    def process_result_value(self, value, dialect):
        return decrypt(value)


class User(Base):
    'A user'
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = column_property(
        Column(Unicode(USERNAME_LEN_MAX), unique=True), 
        comparator_factory=CaseInsensitiveComparator)
    password_ = Column('password', LargeBinary(60)) # Hash from bcrypt
    @hybrid_property
    def password(self):
        return self.password_
    @password.setter
    def password(self, password):
        self.password_ = crypt.encode(password)
    nickname = column_property(
        Column(Unicode(NICKNAME_LEN_MAX), unique=True),
        comparator_factory=CaseInsensitiveComparator)
    email = Column(LowercaseEncrypted(EMAIL_LEN_MAX * 2), unique=True) # Doubled for unicode addresses
    role = Column(Integer, default=ROLE_SPECTATOR)
    rejection_count = Column(Integer, default=0)
    minutes_offset = Column(Integer, default=0)
    when_login = Column(DateTime)
    code = Column(String(CODE_LEN), default=lambda: make_random_string(CODE_LEN))
    sms_addresses = relationship('SMSAddress')

    def __str__(self):
        return "<User(id=%s)>" % self.id

    def check(self, password):
        'Return True if we have a matching password'
        return crypt.check(self.password, password)


class User_(Base):
    'An unconfirmed change to a user account'
    __tablename__ = 'users_'
    id = Column(Integer, primary_key=True)
    username = column_property(
        Column(Unicode(USERNAME_LEN_MAX)), 
        comparator_factory=CaseInsensitiveComparator)
    password_ = Column('password', LargeBinary(60)) # Hash from bcrypt
    @hybrid_property
    def password(self):
        return self.password_
    @password.setter
    def password(self, password):
        self.password_ = crypt.encode(password)
    nickname = column_property(
        Column(Unicode(NICKNAME_LEN_MAX)), 
        comparator_factory=CaseInsensitiveComparator)
    email = Column(LowercaseEncrypted(EMAIL_LEN_MAX * 2)) # Doubled for unicode addresses
    user_id = Column(ForeignKey('users.id'))
    ticket = Column(String(TICKET_LEN), unique=True)
    when_expire = Column(DateTime)

    def __str__(self):
        return "<User_(id=%s)>" % self.id


class SMSAddress(Base):
    'An SMS address'
    __tablename__ = 'sms_addresses'
    id = Column(Integer, primary_key=True)
    email = Column(LowercaseEncrypted(EMAIL_LEN_MAX * 2)) # Doubled for unicode addresses
    user_id = Column(ForeignKey('users.id'))
    is_active = Column(Boolean, default=False)

    def __str__(self):
        return "<SMSAddress(id=%s)>" % self.id


class Row(Base):
    'A row'
    __tablename__ = 'rows'
    id = Column(Integer, primary_key=True)
    col1 = Column(Unicode(64))
    col2 = Column(Unicode(64))

    def __str__(self):
        return "<Row(id=%s)>" % self.id


def initialize_sql(engine):
    'Create tables and insert data'
    # Create tables
    db.configure(bind=engine)
    Base.metadata.bind = engine
    Base.metadata.create_all(engine)
    # If we have no users,
    if not db.query(User).count():
        # Prepare sample data
        userPacks = [
            (ROLE_LEADER, u'leader'),
            (ROLE_MEMBER, u'member'),
            (ROLE_SPECTATOR, u'spectator'),
        ]
        # Insert data
        for role, word in userPacks:
            userD = dict(
                username=word, 
                password=make_random_string(PASSWORD_LEN_MAX),
                nickname=word.title(),
                email=word + '@example.com',
                role=role)
            print '\nUsername  %(username)s\nPassword  %(password)s' % userD
            db.add(User(**userD))
        print
        transaction.commit()
