'Data models'
import transaction
from sqlalchemy import func, Column, ForeignKey, Boolean, Integer, String, Unicode, LargeBinary, DateTime, engine_from_config
from sqlalchemy.pool import QueuePool, NullPool
from sqlalchemy.orm import scoped_session, sessionmaker, relationship
from sqlalchemy.ext.hybrid import hybrid_property, Comparator
from sqlalchemy.ext.declarative import declarative_base
from zope.sqlalchemy import ZopeTransactionExtension
from cryptacular import bcrypt
from formencode import validators, Invalid

from {{package}}.libraries.tools import encrypt, decrypt, make_random_string
from {{package}}.parameters import *


ROLE_SPECTATOR, ROLE_MEMBER, ROLE_LEADER = xrange(3)
db = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))
Base = declarative_base()
crypt = bcrypt.BCRYPTPasswordManager()


class ApplicationError(Exception):
    'An application error'
    pass


class CaseInsensitiveUnicode(unicode):

    def __lt__(self, other):
        return self.lower() < other.lower()

    def __le__(self, other):
        return self.lower() <= other.lower()

    def __eq__(self, other):
        return self.lower() == other.lower()

    def __ne__(self, other):
        return self.lower() != other.lower()

    def __gt__(self, other):
        return self.lower() > other.lower()

    def __ge__(self, other):
        return self.lower() >= other.lower()


class CaseInsensitiveComparator(Comparator):

    def operate(self, op, other, **kwargs):
        return op(func.lower(self.__clause_element__()), func.lower(other), **kwargs)


class CaseInsensitiveEncryptComparator(Comparator):

    def operate(self, op, other, **kwargs):
        return op(self.__clause_element__(), encrypt(other.lower()), **kwargs)


class EmailMixin(object):
    'Mixin class for a case-insensitive encrypted email address'
    email_ = Column(LargeBinary(EMAIL_LEN_MAX * 2)) # Doubled for unicode addresses
    @hybrid_property
    def email(self):
        return CaseInsensitiveUnicode(decrypt(self.email_))
    @email.setter
    def email(self, email):
        self.email_ = encrypt(email.lower())
    @email.comparator
    def email(cls):
        return CaseInsensitiveEncryptComparator(cls.email_)


class UserMixin(EmailMixin):
    'Mixin class for common user fields'
    username_ = Column(Unicode(USERNAME_LEN_MAX))
    @hybrid_property
    def username(self):
        return CaseInsensitiveUnicode(self.username_)
    @username.setter
    def username(self, username):
        self.username_ = username
    @username.comparator
    def username(cls):
        return CaseInsensitiveComparator(cls.username_)

    password_ = Column(LargeBinary(60))
    @hybrid_property
    def password(self):
        return self.password_
    @password.setter
    def password(self, password):
        self.password_ = crypt.encode(password)

    nickname_ = Column(Unicode(NICKNAME_LEN_MAX))
    @hybrid_property
    def nickname(self):
        return CaseInsensitiveUnicode(self.nickname_)
    @nickname.setter
    def nickname(self, nickname):
        self.nickname_ = nickname
    @nickname.comparator
    def nickname(cls):
        return CaseInsensitiveComparator(cls.nickname_)


class User(Base, UserMixin):
    'A user'
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    role = Column(Integer, default=ROLE_SPECTATOR)
    rejection_count = Column(Integer, default=0)
    minutes_offset = Column(Integer, default=0)
    when_login = Column(DateTime)
    code = Column(String(CODE_LEN), default=lambda: make_random_string(CODE_LEN))
    sms_addresses = relationship('SMSAddress')

    def check(self, password):
        'Return True if we have a matching password'
        return crypt.check(self.password, password)


class User_(Base, UserMixin):
    'An unconfirmed change to a user account'
    __tablename__ = 'users_'
    id = Column(Integer, primary_key=True)
    user_id = Column(ForeignKey('users.id'))
    ticket = Column(String(TICKET_LEN), unique=True)
    when_expire = Column(DateTime)


class SMSAddress(Base, EmailMixin):
    'An SMS address'
    __tablename__ = 'sms_addresses'
    id = Column(Integer, primary_key=True)
    user_id = Column(ForeignKey('users.id'))
    is_active = Column(Boolean, default=False)


class Row(Base):
    'A row'
    __tablename__ = 'rows'
    id = Column(Integer, primary_key=True)
    col1 = Column(Unicode(64))
    col2 = Column(Unicode(64))


def initialize_sql(settings):
    'Create tables and insert data'
    # Create tables
    engine = engine_from_config(settings, 'sqlalchemy.', poolclass=NullPool if settings['sqlalchemy.url'].startswith('sqlite:///') else QueuePool)
    db.configure(bind=engine)
    Base.metadata.bind = engine
    Base.metadata.create_all(engine)
    # If we have no users,
    if not db.query(User).count():
        # If we are in development mode,
        if settings['debug_templates'] == 'true':
            userPacks = [
                (ROLE_LEADER, u'leader'),
                (ROLE_MEMBER, u'member'),
                (ROLE_SPECTATOR, u'spectator'),
            ]
        # If we are in production mode,
        else:
            userPacks = [
                (ROLE_LEADER, u'admin'),
            ]
        # Insert data
        for role, word in userPacks:
            userD = dict(
                username=word, 
                password=make_random_string(PASSWORD_LEN_MAX),
                nickname=word.title(),
                email=word + '@example.com',
                role=role)
            print '\nUsername  %(username)s\nPassword  %(password)s' % userD
            db.add(User(**userD))
        print
        transaction.commit()


class Unique(validators.FancyValidator):
    'Validator to ensure that the value of a field is unique'

    def __init__(self, Class, fieldName, errorMessage):
        'Store class, fieldName, errorMessage'
        super(Unique, self).__init__()
        self.Class = Class
        self.fieldName = fieldName
        self.errorMessage = errorMessage

    def _to_python(self, value, classInstance):
        'Check whether the value is unique'
        # If the classInstance is new or the value changed,
        if not classInstance or getattr(classInstance, self.fieldName) != value:
            query = db.query(self.Class)
            # If the value exists, raise formencode.Invalid
            if query.filter(getattr(self.Class, self.fieldName)==value).first():
                raise Invalid(self.errorMessage, value, classInstance)
        # Return
        return value
